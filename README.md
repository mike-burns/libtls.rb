# libtls for Ruby

This is a set of libtls bindings for Ruby, plus a nice OO layer atop the
bindings.

This is a work in progress. If you figure out how to use this, please
contribute back with documentation, bindings, and bug fixes.

## Installation

Add this line to your application's Gemfile:

```ruby
gem 'libtls'
```

And then execute:

    $ bundle

Or install it yourself as:

    $ gem install libtls

## Usage

This library provides the API on two levels: the raw C functions, and a nice OO
layer atop it.

### Raw

The raw functions are as follows; see `tls_init`(3) for more information on what
they do:

- `LibTLS::Raw.tls_init`
- `LibTLS::Raw.tls_client`
- `LibTLS::Raw.tls_close`
- `LibTLS::Raw.tls_connect`
- `LibTLS::Raw.tls_configure`
- `LibTLS::Raw.tls_config_new`
- `LibTLS::Raw.tls_config_set_ciphers`
- `LibTLS::Raw.tls_config_set_protocols`
- `LibTLS::Raw.tls_config_set_ca_file`
- `LibTLS::Raw.tls_config_free`
- `LibTLS::Raw.tls_free`
- `LibTLS::Raw.tls_write`
- `LibTLS::Raw.tls_read`
- `LibTLS::Raw.tls_error`
- `LibTLS::Raw.tls_server`
- `LibTLS::Raw.tls_config_set_key_file`
- `LibTLS::Raw.tls_config_set_cert_file`
- `LibTLS::Raw.tls_accept_socket`

Of particular note are those functions which take a pointer (`tls_read`,
`tls_write`, and `tls_accept_socket`). These must have an instance of
`FFI::MemoryPointer` passed to them:

```ruby
FFI::MemoryPointer.new(:size_t) do |outlen|
  FFI::MemoryPointer.new(:uchar, 1024, true) do |buf|

    ret = LibTLS::Raw.tls_read(client, buf, 1024, outlen)

    if ret < 0
      raise "tls_read: #{LibTLS::Raw.tls_error(client)}"
    end

  end
end
```

Additionally, instance of Ruby's `Socket` object must be converted to their
file descriptor before interfacing with the C function. The `tls_accept_socket`
function combines the `FFI::MemoryPointer` requirement with this file
descriptor requirement:

```ruby
  cctx_ptr = FFI::MemoryPointer.new(:pointer)

  if tls_accept_socket(server, cctx_ptr, socket.fileno) == -1
    raise "tls_accept_socket: #{LibTLS::Raw.tls_error(server)}"
  end

  cctx = cctx_ptr.read_pointer
```

### OO

An object-oriented wrapper is provided. Here is an example of a client:

```ruby
# Get the contents of the Web page hosted at https://#{hostname}:443#{path} .
def get(hostname, path)
  # The return value: nil, or a string.
  content = nil

  # TLS configuration. The key is formed from the series of tls_config_set_*
  # functions; the value is either the scalar value (int or string), or an
  # array of the multiple values. For example, ca_mem takes an array with the
  # FFI::MemoryPointer and the length of that pointer.
  config = {
    ciphers: "DES-CBC3-SHA",
    protocols: LibTLS::PROTOCOL_ALL
  }

  # Create a new libtls client. The block is then immediately run, and then the
  # memory free'd.
  LibTLS::Client.new(configure: config) do |client|
    # Connect to the server on port 443. When the block finishes, disconnect.
    content = client.connect("mike-burns.com", 443) do |c|
      # Send a string to the server; in this case, a HTTP request.
      c.write(http_get(hostname, path))
      # Read all the data from the server, and return it. The return value of
      # this block is the return value of Client#connect.
      c.read
    end
  end

  # Return the content.
  content
end

# Generate a HTTP request string.
def http_get(hostname, path)
  ["GET #{path} HTTP/1.1",
   "User-Agent: libtls.rb/0.1",
   "Host: #{hostname}"].join("\r\n") +
   "\r\n"
end
```

And here is an example of a simple echo server:

```ruby
# Reply to the socket's clients with their own string.
def echo_server(socket)
  # Encrypt communications using the key and cert as generated by e.g.
  # LibreSSL.
  config = {
      key_file: "thekey.key",
      cert_file: "thecert.crt"
  }

  # Create and configure a new server object. The block is then immediately
  # run, and then the memory is free'd.
  LibTLS::Server.new(configure: config) do |server|
    # Block until a client connects on client_socket.
    client_socket, _ = socket.accept

    # Loop forever; this allows another client to connect after this one.
    loop do
      # Handle the TLS handshake on the client socket. This takes a block,
      # which is run immediately after the handshake has completed
      # successfully. After the block finishes, disconnect and clean up. The
      # block takes an opened client object.
      server.accept(client_socket) do |c|
        # Loop so that the client can write until they disconnect.
        loop do
          # Read the entirety of the client's string.
          str = c.read
          # Write exactly what the client sent.
          c.write(str)
        end
      end
    end
  end
end
```

## Contributing

1. Fork it ( https://github.com/mike-burns/libtls.rb/fork )
2. Make sure the tests pass (`rake`)
3. Create your feature branch (`git checkout -b my-new-feature`)
4. Commit your changes (`git commit -am 'Add some feature'`)
5. Push to the branch (`git push origin my-new-feature`)
6. Make sure the tests pass (`rake`)
7. Create a new Pull Request

## Authors

* [Mike Burns](https://mike-burns.com)

[Donate to the OpenBSD Foundation](http://www.openbsdfoundation.org/donations.html).

Released under the [ISC license][LICENSE].

[LICENSE]: LICENSE
